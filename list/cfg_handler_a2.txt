; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\cfg_handler_a2.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\cfg_handler_a2.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\cstartup -I.\drivers\uart -I.\app\cfg -I.\iap -I.\drivers -I.\usb -I.\drivers\adc -I.\drivers\gpio -I.\drivers -I.\RTE\_lpc17xx_can_loader_debug -IC:\Keil_v5\ARM\PACK\Keil\LPC1700_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=523 -DLPC175x_6x -D__DEBUG_UART2_PRINTF__ -D__UART0__ -D__UART1__ -D__UART2__ -D__UART3__ -D__UART2_ENABLE__ -D__UART3_ENABLE__ -D__UART0_ENABLE__ -D__UART1_ENABLE__ --omf_browse=.\output\cfg_handler_a2.crf app\cfg\cfg_handler_a2.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  cfg_get_handler PROC
;;;437    
;;;438    ptr_func_handler cfg_get_handler(uint16_t cmd_id)
000000  4602              MOV      r2,r0
;;;439    {
;;;440    	int i = 0;
000002  2100              MOVS     r1,#0
;;;441    
;;;442    	for( i = 0; cmd_handler_array[i].handler != NULL; i++)
000004  bf00              NOP      
000006  e00b              B        |L1.32|
                  |L1.8|
;;;443    	{
;;;444    		if(cmd_id == cmd_handler_array[i].cmd_id)
000008  48fe              LDR      r0,|L1.1028|
00000a  eb0000c1          ADD      r0,r0,r1,LSL #3
00000e  8880              LDRH     r0,[r0,#4]
000010  4290              CMP      r0,r2
000012  d104              BNE      |L1.30|
;;;445    		{
;;;446    			return cmd_handler_array[i].handler;
000014  48fb              LDR      r0,|L1.1028|
000016  eb0000c1          ADD      r0,r0,r1,LSL #3
00001a  6800              LDR      r0,[r0,#0]
                  |L1.28|
;;;447    		}
;;;448    
;;;449    	}
;;;450    
;;;451    	return NULL;
;;;452    }
00001c  4770              BX       lr
                  |L1.30|
00001e  1c49              ADDS     r1,r1,#1              ;442
                  |L1.32|
000020  48f8              LDR      r0,|L1.1028|
000022  eb0000c1          ADD      r0,r0,r1,LSL #3       ;442
000026  6800              LDR      r0,[r0,#0]            ;442
000028  2800              CMP      r0,#0                 ;442
00002a  d1ed              BNE      |L1.8|
00002c  bf00              NOP                            ;451
00002e  e7f5              B        |L1.28|
;;;453    
                          ENDP

                  cfg_cmd_process_v2 PROC
;;;454    void cfg_cmd_process_v2(uint8_t *buf, uint16_t buf_len)
000030  e92d41f0          PUSH     {r4-r8,lr}
;;;455    {    
000034  4604              MOV      r4,r0
000036  460d              MOV      r5,r1
;;;456    	CMD_HEADER_t     *cmd_header = NULL;
000038  2600              MOVS     r6,#0
;;;457    	ptr_func_handler cmd_handler = NULL;
00003a  2700              MOVS     r7,#0
;;;458    
;;;459    	if(buf_len <sizeof(CMD_HEADER_t))
00003c  2d1a              CMP      r5,#0x1a
00003e  d201              BCS      |L1.68|
                  |L1.64|
;;;460    	{
;;;461    		//TODO: test & warn
;;;462    		return;
;;;463    	}
;;;464    	cmd_header = (CMD_HEADER_t*)(buf);
;;;465    
;;;466    	//TODO: process with EncrypType, maybe will change buf_len
;;;467       uart_printf(0,"cmd 0x%04x\r\n",cmd_header->cmd_id);
;;;468    	cmd_handler = cfg_get_handler(cmd_header->cmd_id);
;;;469    
;;;470    	if(cmd_handler != NULL)
;;;471    	{
;;;472    		cmd_handler(buf,buf_len);
;;;473    	}else
;;;474    	{
;;;475    		//to main board
;;;476         can_upgrade_ack((void *)buf,buf_len);
;;;477    	}
;;;478    }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L1.68|
000044  4626              MOV      r6,r4                 ;464
000046  f8b62005          LDRH     r2,[r6,#5]            ;467
00004a  a1ef              ADR      r1,|L1.1032|
00004c  2000              MOVS     r0,#0                 ;467
00004e  f7fffffe          BL       uart_printf
000052  f8b60005          LDRH     r0,[r6,#5]            ;468
000056  f7fffffe          BL       cfg_get_handler
00005a  4607              MOV      r7,r0                 ;468
00005c  b11f              CBZ      r7,|L1.102|
00005e  4629              MOV      r1,r5                 ;472
000060  4620              MOV      r0,r4                 ;472
000062  47b8              BLX      r7                    ;472
000064  e003              B        |L1.110|
                  |L1.102|
000066  4629              MOV      r1,r5                 ;476
000068  4620              MOV      r0,r4                 ;476
00006a  f7fffffe          BL       can_upgrade_ack
                  |L1.110|
00006e  bf00              NOP      
000070  e7e6              B        |L1.64|
;;;479    
                          ENDP

                  valuate_checksum PROC
;;;480    int valuate_checksum(uint8_t *buf,  uint16_t buf_len)
000072  b570              PUSH     {r4-r6,lr}
;;;481    {
000074  4605              MOV      r5,r0
000076  460c              MOV      r4,r1
;;;482    	unsigned short wExpected = 0;
000078  2600              MOVS     r6,#0
;;;483    
;;;484        if ((buf == NULL) || (buf_len <= 2))
00007a  b10d              CBZ      r5,|L1.128|
00007c  2c02              CMP      r4,#2
00007e  dc02              BGT      |L1.134|
                  |L1.128|
;;;485        {
;;;486            return -1;
000080  f04f30ff          MOV      r0,#0xffffffff
                  |L1.132|
;;;487        }
;;;488        wExpected = Get_CRC16_Check_Sum ( (unsigned char*)buf, buf_len - 4, CRC_INIT);
;;;489    
;;;490        return ((char)(wExpected & 0xff) == buf[buf_len - 2] &&
;;;491    		(char)((wExpected >> 8) & 0xff) == buf[buf_len - 1]);
;;;492    
;;;493    	//TODO: new check sum algorithm
;;;494        //return 1;
;;;495    }
000084  bd70              POP      {r4-r6,pc}
                  |L1.134|
000086  1f21              SUBS     r1,r4,#4              ;488
000088  f2436292          MOV      r2,#0x3692            ;488
00008c  4628              MOV      r0,r5                 ;488
00008e  f7fffffe          BL       Get_CRC16_Check_Sum
000092  4606              MOV      r6,r0                 ;488
000094  b2f1              UXTB     r1,r6                 ;490
000096  1ea0              SUBS     r0,r4,#2              ;490
000098  5c28              LDRB     r0,[r5,r0]            ;490
00009a  4281              CMP      r1,r0                 ;490
00009c  d106              BNE      |L1.172|
00009e  1e60              SUBS     r0,r4,#1              ;491
0000a0  5c28              LDRB     r0,[r5,r0]            ;491
0000a2  ebb02f16          CMP      r0,r6,LSR #8          ;491
0000a6  d101              BNE      |L1.172|
0000a8  2001              MOVS     r0,#1                 ;490
0000aa  e7eb              B        |L1.132|
                  |L1.172|
0000ac  2000              MOVS     r0,#0                 ;490
0000ae  e7e9              B        |L1.132|
;;;496    
                          ENDP

                  cfg_unpack_tick_a2 PROC
;;;57     /* 带CRC校验的数据包 解包 */
;;;58     void cfg_unpack_tick_a2 (void)        
0000b0  b570              PUSH     {r4-r6,lr}
;;;59     {
;;;60     	uint32_t cnt  = 0;
0000b2  2500              MOVS     r5,#0
;;;61     	uint8_t byte = 0;
0000b4  2400              MOVS     r4,#0
;;;62     
;;;63     	cnt = CAN_RING_BUF_COUNT( &can1RxUpgradeRingBuf );
0000b6  48d8              LDR      r0,|L1.1048|
0000b8  f7fffffe          BL       CAN_RING_BUF_COUNT
0000bc  4605              MOV      r5,r0
;;;64     
;;;65     	while(cnt--)
0000be  e0a9              B        |L1.532|
                  |L1.192|
;;;66     	{
;;;67     		byte = CAN_RING_BUF_RD( &can1RxUpgradeRingBuf );
0000c0  48d5              LDR      r0,|L1.1048|
0000c2  f7fffffe          BL       CAN_RING_BUF_RD
0000c6  4604              MOV      r4,r0
;;;68     		//uart_printf(0,"%.2x",byte);
;;;69     		switch(cfg_unpack_state)
0000c8  48d4              LDR      r0,|L1.1052|
0000ca  7800              LDRB     r0,[r0,#0]  ; cfg_unpack_state
0000cc  2808              CMP      r0,#8
0000ce  d270              BCS      |L1.434|
0000d0  e8dff000          TBB      [pc,r0]
0000d4  9b040a14          DCB      0x9b,0x04,0x0a,0x14
0000d8  1e282e70          DCB      0x1e,0x28,0x2e,0x70
;;;70     		{
;;;71     			case CAN_CRC_PACK_STATE_HEADER1:
;;;72     			{
;;;73     				if(byte==CAN_CRC_PACK_HEADER1) cfg_unpack_state = CAN_CRC_PACK_STATE_HEADER2;
0000dc  2c55              CMP      r4,#0x55
0000de  d102              BNE      |L1.230|
0000e0  2002              MOVS     r0,#2
0000e2  49ce              LDR      r1,|L1.1052|
0000e4  7008              STRB     r0,[r1,#0]
                  |L1.230|
;;;74     			}break;
0000e6  e094              B        |L1.530|
;;;75     			
;;;76     			case CAN_CRC_PACK_STATE_HEADER2:
;;;77     			{
;;;78     				if(byte==CAN_CRC_PACK_HEADER2) cfg_unpack_state = CAN_CRC_PACK_STATE_HEADER3;  //new protocol
0000e8  2caa              CMP      r4,#0xaa
0000ea  d103              BNE      |L1.244|
0000ec  2003              MOVS     r0,#3
0000ee  49cb              LDR      r1,|L1.1052|
0000f0  7008              STRB     r0,[r1,#0]
0000f2  e002              B        |L1.250|
                  |L1.244|
;;;79     				else cfg_unpack_state = CAN_CRC_PACK_STATE_HEADER1;				
0000f4  2001              MOVS     r0,#1
0000f6  49c9              LDR      r1,|L1.1052|
0000f8  7008              STRB     r0,[r1,#0]
                  |L1.250|
;;;80     			}break;
0000fa  e08a              B        |L1.530|
;;;81     			
;;;82     			case CAN_CRC_PACK_STATE_HEADER3:
;;;83     			{
;;;84     				if(byte==CAN_CRC_PACK_HEADER3) cfg_unpack_state = CAN_CRC_PACK_STATE_HEADER4;
0000fc  2c55              CMP      r4,#0x55
0000fe  d103              BNE      |L1.264|
000100  2004              MOVS     r0,#4
000102  49c6              LDR      r1,|L1.1052|
000104  7008              STRB     r0,[r1,#0]
000106  e002              B        |L1.270|
                  |L1.264|
;;;85     				else cfg_unpack_state = CAN_CRC_PACK_STATE_HEADER1;
000108  2001              MOVS     r0,#1
00010a  49c4              LDR      r1,|L1.1052|
00010c  7008              STRB     r0,[r1,#0]
                  |L1.270|
;;;86     			}break;
00010e  e080              B        |L1.530|
;;;87     			
;;;88     			case CAN_CRC_PACK_STATE_HEADER4:
;;;89     			{
;;;90     				if(byte==CAN_CRC_PACK_HEADER4) {cfg_unpack_state = CAN_CRC_PACK_STATE_LEN_L;}
000110  2caa              CMP      r4,#0xaa
000112  d103              BNE      |L1.284|
000114  2005              MOVS     r0,#5
000116  49c1              LDR      r1,|L1.1052|
000118  7008              STRB     r0,[r1,#0]
00011a  e002              B        |L1.290|
                  |L1.284|
;;;91     				else cfg_unpack_state = CAN_CRC_PACK_STATE_HEADER1;	
00011c  2001              MOVS     r0,#1
00011e  49bf              LDR      r1,|L1.1052|
000120  7008              STRB     r0,[r1,#0]
                  |L1.290|
;;;92     			}break;
000122  e076              B        |L1.530|
;;;93     			
;;;94     			case CAN_CRC_PACK_STATE_LEN_L:
;;;95     			{
;;;96     				cfg_unpack_len_low = byte;
000124  48be              LDR      r0,|L1.1056|
000126  7004              STRB     r4,[r0,#0]
;;;97     				cfg_unpack_state   = CAN_CRC_PACK_STATE_LEN_H;	
000128  2006              MOVS     r0,#6
00012a  49bc              LDR      r1,|L1.1052|
00012c  7008              STRB     r0,[r1,#0]
;;;98     			}break;
00012e  e070              B        |L1.530|
;;;99     			
;;;100    			case CAN_CRC_PACK_STATE_LEN_H:
;;;101    			{
;;;102    				cfg_unpack_len = (uint16_t)byte;
000130  48bc              LDR      r0,|L1.1060|
000132  8004              STRH     r4,[r0,#0]
;;;103    				cfg_unpack_len = (cfg_unpack_len << 8) |  cfg_unpack_len_low;
000134  48ba              LDR      r0,|L1.1056|
000136  7800              LDRB     r0,[r0,#0]  ; cfg_unpack_len_low
000138  49ba              LDR      r1,|L1.1060|
00013a  7809              LDRB     r1,[r1,#0]  ; cfg_unpack_len
00013c  ea402001          ORR      r0,r0,r1,LSL #8
000140  49b8              LDR      r1,|L1.1060|
000142  8008              STRH     r0,[r1,#0]
;;;104    
;;;105    				/* for sim temp use */
;;;106    				if(((cfg_unpack_len&0xff00)>>8 == 0x05) || ((cfg_unpack_len&0xff00)>>8 == 0xdd))
000144  4608              MOV      r0,r1
000146  8800              LDRH     r0,[r0,#0]  ; cfg_unpack_len
000148  2105              MOVS     r1,#5
00014a  ebb12f10          CMP      r1,r0,LSR #8
00014e  d005              BEQ      |L1.348|
000150  48b4              LDR      r0,|L1.1060|
000152  8800              LDRH     r0,[r0,#0]  ; cfg_unpack_len
000154  21dd              MOVS     r1,#0xdd
000156  ebb12f10          CMP      r1,r0,LSR #8
00015a  d112              BNE      |L1.386|
                  |L1.348|
;;;107    				{
;;;108    					cfg_unpack_len    = cfg_unpack_len_low;
00015c  48b0              LDR      r0,|L1.1056|
00015e  7800              LDRB     r0,[r0,#0]  ; cfg_unpack_len_low
000160  49b0              LDR      r1,|L1.1060|
000162  8008              STRH     r0,[r1,#0]
;;;109    					cfg_unpack_rdIdx  = 2;
000164  2002              MOVS     r0,#2
000166  49b0              LDR      r1,|L1.1064|
000168  8008              STRH     r0,[r1,#0]
;;;110    					cfg_unpack_state  = CAN_CRC_PACK_STATE_DATA_SIM;
00016a  2008              MOVS     r0,#8
00016c  49ab              LDR      r1,|L1.1052|
00016e  7008              STRB     r0,[r1,#0]
;;;111    					cfg_unpack_buf[0] = cfg_unpack_len_low;
000170  48ab              LDR      r0,|L1.1056|
000172  7800              LDRB     r0,[r0,#0]  ; cfg_unpack_len_low
000174  49ad              LDR      r1,|L1.1068|
000176  7008              STRB     r0,[r1,#0]
;;;112    					cfg_unpack_buf[1] = (CPU_INT08U)((cfg_unpack_len&0xff00)>>8);
000178  48aa              LDR      r0,|L1.1060|
00017a  8800              LDRH     r0,[r0,#0]  ; cfg_unpack_len
00017c  0a00              LSRS     r0,r0,#8
00017e  7048              STRB     r0,[r1,#1]
;;;113    					break;
000180  e047              B        |L1.530|
                  |L1.386|
;;;114    				}
;;;115    				
;;;116    				if( cfg_unpack_len >= CFG_UNPACK_BUF_MAX_LEN )
000182  48a8              LDR      r0,|L1.1060|
000184  8800              LDRH     r0,[r0,#0]  ; cfg_unpack_len
000186  f5b07f00          CMP      r0,#0x200
00018a  db03              BLT      |L1.404|
;;;117    				{
;;;118    					//VCOM_printf_debug(" check point %s %s 0x%04x\r\n",__FUNCTION__,__LINE__,cmd_length);
;;;119    					cfg_unpack_state = CAN_CRC_PACK_STATE_HEADER1;
00018c  2001              MOVS     r0,#1
00018e  49a3              LDR      r1,|L1.1052|
000190  7008              STRB     r0,[r1,#0]
000192  e00d              B        |L1.432|
                  |L1.404|
;;;120    				}
;;;121    				else
;;;122    				{
;;;123    					//VCOM_printf(" check point %s %s\r\n",__FUNCTION__,__LINE__);
;;;124    					cfg_unpack_buf[0] = cfg_unpack_len_low;
000194  48a2              LDR      r0,|L1.1056|
000196  7800              LDRB     r0,[r0,#0]  ; cfg_unpack_len_low
000198  49a4              LDR      r1,|L1.1068|
00019a  7008              STRB     r0,[r1,#0]
;;;125    					cfg_unpack_buf[1] = (CPU_INT08U)((cfg_unpack_len&0xff00)>>8);
00019c  48a1              LDR      r0,|L1.1060|
00019e  8800              LDRH     r0,[r0,#0]  ; cfg_unpack_len
0001a0  0a00              LSRS     r0,r0,#8
0001a2  7048              STRB     r0,[r1,#1]
;;;126    					cfg_unpack_rdIdx  = 2;
0001a4  2002              MOVS     r0,#2
0001a6  49a0              LDR      r1,|L1.1064|
0001a8  8008              STRH     r0,[r1,#0]
;;;127    
;;;128    					cfg_unpack_state  = CAN_CRC_PACK_STATE_DATA;
0001aa  2007              MOVS     r0,#7
0001ac  499b              LDR      r1,|L1.1052|
0001ae  7008              STRB     r0,[r1,#0]
                  |L1.432|
;;;129    				}	
;;;130    			}break;
0001b0  e02f              B        |L1.530|
                  |L1.434|
0001b2  e02a              B        |L1.522|
;;;131    			
;;;132    			case CAN_CRC_PACK_STATE_DATA:
;;;133    			{
;;;134    				if(cfg_unpack_rdIdx < cfg_unpack_len) 	   /*Note: com_i begin with 2	*/
0001b4  489c              LDR      r0,|L1.1064|
0001b6  8800              LDRH     r0,[r0,#0]  ; cfg_unpack_rdIdx
0001b8  499a              LDR      r1,|L1.1060|
0001ba  8809              LDRH     r1,[r1,#0]  ; cfg_unpack_len
0001bc  4288              CMP      r0,r1
0001be  da08              BGE      |L1.466|
;;;135    				{
;;;136    					cfg_unpack_buf[cfg_unpack_rdIdx] = byte;
0001c0  489a              LDR      r0,|L1.1068|
0001c2  4999              LDR      r1,|L1.1064|
0001c4  8809              LDRH     r1,[r1,#0]  ; cfg_unpack_rdIdx
0001c6  5444              STRB     r4,[r0,r1]
;;;137    					++cfg_unpack_rdIdx;
0001c8  4897              LDR      r0,|L1.1064|
0001ca  8800              LDRH     r0,[r0,#0]  ; cfg_unpack_rdIdx
0001cc  1c40              ADDS     r0,r0,#1
0001ce  4996              LDR      r1,|L1.1064|
0001d0  8008              STRH     r0,[r1,#0]
                  |L1.466|
;;;138    				}
;;;139    				if(cfg_unpack_rdIdx >= cfg_unpack_len)
0001d2  4895              LDR      r0,|L1.1064|
0001d4  8800              LDRH     r0,[r0,#0]  ; cfg_unpack_rdIdx
0001d6  4993              LDR      r1,|L1.1060|
0001d8  8809              LDRH     r1,[r1,#0]  ; cfg_unpack_len
0001da  4288              CMP      r0,r1
0001dc  db14              BLT      |L1.520|
;;;140    				{
;;;141    					cfg_unpack_state = CAN_CRC_PACK_STATE_HEADER1;
0001de  2001              MOVS     r0,#1
0001e0  498e              LDR      r1,|L1.1052|
0001e2  7008              STRB     r0,[r1,#0]
;;;142    
;;;143    					uart_printf(0,"47:%.2x \r\n",cfg_unpack_len);
0001e4  488f              LDR      r0,|L1.1060|
0001e6  8802              LDRH     r2,[r0,#0]  ; cfg_unpack_len
0001e8  a191              ADR      r1,|L1.1072|
0001ea  2000              MOVS     r0,#0
0001ec  f7fffffe          BL       uart_printf
;;;144    //				    ctrl_to_wl_package_forward(1, &ctrl_unpack_buf[0], ctrl_unpack_len);
;;;145    					if( 1 == valuate_checksum(cfg_unpack_buf, cfg_unpack_len) ) /*Checksum succeed*/
0001f0  488c              LDR      r0,|L1.1060|
0001f2  8801              LDRH     r1,[r0,#0]  ; cfg_unpack_len
0001f4  488d              LDR      r0,|L1.1068|
0001f6  f7fffffe          BL       valuate_checksum
0001fa  2801              CMP      r0,#1
0001fc  d104              BNE      |L1.520|
;;;146    					{
;;;147    //						uart_printf(0,"check sum here\r\n");
;;;148    						//cfg_unpack_complete = 1;
;;;149    						cfg_cmd_process_v2(cfg_unpack_buf, cfg_unpack_len);
0001fe  4889              LDR      r0,|L1.1060|
000200  8801              LDRH     r1,[r0,#0]  ; cfg_unpack_len
000202  488a              LDR      r0,|L1.1068|
000204  f7fffffe          BL       cfg_cmd_process_v2
                  |L1.520|
;;;150    					}
;;;151    					else
;;;152    					{
;;;153    					    //uart_printf(0,"check sum error\r\n");
;;;154    						/*TODO: Warn an err. */
;;;155    					}
;;;156    				}
;;;157    			}break;
000208  e003              B        |L1.530|
                  |L1.522|
;;;158    
;;;159    			default:
;;;160    			{
;;;161    			    cfg_unpack_state = CAN_CRC_PACK_STATE_HEADER1;
00020a  2001              MOVS     r0,#1
00020c  4983              LDR      r1,|L1.1052|
00020e  7008              STRB     r0,[r1,#0]
;;;162    				break;
000210  bf00              NOP      
                  |L1.530|
000212  bf00              NOP                            ;74
                  |L1.532|
000214  1e28              SUBS     r0,r5,#0              ;65
000216  f1a50501          SUB      r5,r5,#1              ;65
00021a  f47faf51          BNE      |L1.192|
;;;163    			}
;;;164    		}
;;;165    
;;;166    // 		if(1 == cfg_unpack_complete)
;;;167    // 		{
;;;168    // 		    cfg_unpack_complete = 0;
;;;169    // 			break; /* 控制解包频率 */ 
;;;170    // 		}
;;;171    	} /*End while*/
;;;172    }
00021e  bd70              POP      {r4-r6,pc}
;;;173    
                          ENDP

                  update_version PROC
;;;174    
;;;175    void update_version(unsigned char* p_d)
000220  4770              BX       lr
;;;176    {
;;;177    //	p_d[0] = ((WKM_OSD_VERSION & 0xff000000) >> 24);
;;;178    //	p_d[1] = ((WKM_OSD_VERSION & 0x00ff0000) >> 16);
;;;179    //	p_d[2] = ((WKM_OSD_VERSION & 0x0000ff00) >> 8);
;;;180    //	p_d[3] = ((WKM_OSD_VERSION & 0x000000ff) );
;;;181    //
;;;182    //	p_d[12] = 0;
;;;183    }
;;;184    
                          ENDP

                  init_cmd_header PROC
;;;185    void init_cmd_header(CMD_HEADER_t* p_head,uint16_t cmd_id,uint16_t bodylength)
000222  b500              PUSH     {lr}
;;;186    {
000224  4603              MOV      r3,r0
;;;187    	p_head->body_length = bodylength;
000226  801a              STRH     r2,[r3,#0]
;;;188     	p_head->protocol_version = 40;//g_version;
000228  2028              MOVS     r0,#0x28
00022a  7098              STRB     r0,[r3,#2]
;;;189    	p_head->cmd_id = cmd_id;
00022c  f8a31005          STRH     r1,[r3,#5]
;;;190    
;;;191    	p_head->flag =0;   // update_flags();
000230  2000              MOVS     r0,#0
000232  f8a30007          STRH     r0,[r3,#7]
;;;192    	p_head->encryp_type = 0;
000236  7258              STRB     r0,[r3,#9]
;;;193    	update_version(p_head->device_id);
000238  f103000a          ADD      r0,r3,#0xa
00023c  f7fffffe          BL       update_version
;;;194    }
000240  bd00              POP      {pc}
;;;195    
                          ENDP

                  deviceInfoInit PROC
;;;196    void deviceInfoInit (void)
000242  b510              PUSH     {r4,lr}
;;;197    {
;;;198      loaderVersion = sbl_get_loader_version();
000244  f7fffffe          BL       sbl_get_loader_version
000248  497c              LDR      r1,|L1.1084|
00024a  6008              STR      r0,[r1,#0]  ; loaderVersion
;;;199      canDeviceId = MY_CAN_DEVICE_ID;  /* led 的编号为4 */
00024c  2024              MOVS     r0,#0x24
00024e  497c              LDR      r1,|L1.1088|
000250  7008              STRB     r0,[r1,#0]
;;;200    	fwVersion = ArgBoardFirmwareVersion;
000252  487c              LDR      r0,|L1.1092|
000254  497c              LDR      r1,|L1.1096|
000256  6008              STR      r0,[r1,#0]  ; fwVersion
;;;201    	canSubDeviceId = 0;
000258  2000              MOVS     r0,#0
00025a  497c              LDR      r1,|L1.1100|
00025c  7008              STRB     r0,[r1,#0]
;;;202    }
00025e  bd10              POP      {r4,pc}
;;;203    
                          ENDP

                  check_sum_calculate PROC
;;;516    }
;;;517    int check_sum_calculate(uint8_t* source,uint16_t source_len,uint16_t* p_des_len)
000260  e92d41f0          PUSH     {r4-r8,lr}
;;;518    {
000264  4604              MOV      r4,r0
000266  460d              MOV      r5,r1
000268  4617              MOV      r7,r2
;;;519    //	if( NULL == source )
;;;520    //	{
;;;521    //			return -1;
;;;522    //	}
;;;523    //
;;;524    //	// TODO: check sum
;;;525    //	*p_des_len = source_len+4;
;;;526    //
;;;527    //	return 1;
;;;528    	unsigned short R_CRC;
;;;529    
;;;530    	if( NULL == source )
00026a  b91c              CBNZ     r4,|L1.628|
;;;531    	{
;;;532    		return -1;
00026c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.624|
;;;533    	}
;;;534    
;;;535    	R_CRC = Get_CRC16_Check_Sum ( (unsigned char *)source, source_len, CRC_INIT );
;;;536    
;;;537        source[source_len+2] = (unsigned char)(R_CRC & 0x00ff);
;;;538        source[source_len+3] = (unsigned char)((R_CRC>>8)& 0x00ff);
;;;539    
;;;540    	*p_des_len = source_len+4;
;;;541    
;;;542    	return 1;
;;;543    }
000270  e8bd81f0          POP      {r4-r8,pc}
                  |L1.628|
000274  f2436292          MOV      r2,#0x3692            ;535
000278  4629              MOV      r1,r5                 ;535
00027a  4620              MOV      r0,r4                 ;535
00027c  f7fffffe          BL       Get_CRC16_Check_Sum
000280  4606              MOV      r6,r0                 ;535
000282  1ca8              ADDS     r0,r5,#2              ;537
000284  5426              STRB     r6,[r4,r0]            ;537
000286  0a31              LSRS     r1,r6,#8              ;538
000288  1ce8              ADDS     r0,r5,#3              ;538
00028a  5421              STRB     r1,[r4,r0]            ;538
00028c  1d28              ADDS     r0,r5,#4              ;540
00028e  8038              STRH     r0,[r7,#0]            ;540
000290  2001              MOVS     r0,#1                 ;542
000292  e7ed              B        |L1.624|
;;;544    
                          ENDP

                  encryp_cmd PROC
;;;497    
;;;498    int encryp_cmd(uint8_t *source, uint16_t source_len, uint8_t* des, uint16_t des_size, uint16_t* p_des_len)
000294  e92d41f0          PUSH     {r4-r8,lr}
;;;499    {
000298  4604              MOV      r4,r0
00029a  460d              MOV      r5,r1
00029c  4616              MOV      r6,r2
00029e  461f              MOV      r7,r3
0002a0  f8dd8018          LDR      r8,[sp,#0x18]
;;;500    	if( NULL == source ||
0002a4  b124              CBZ      r4,|L1.688|
;;;501    		NULL == des ||
0002a6  b11e              CBZ      r6,|L1.688|
;;;502    		source == des ||
0002a8  42b4              CMP      r4,r6
0002aa  d001              BEQ      |L1.688|
;;;503    		des_size < source_len )
0002ac  42af              CMP      r7,r5
0002ae  da03              BGE      |L1.696|
                  |L1.688|
;;;504    	{
;;;505    			return -1;
0002b0  f04f30ff          MOV      r0,#0xffffffff
                  |L1.692|
;;;506    	}
;;;507    
;;;508    	//TODO: encrytion
;;;509    
;;;510    	memcpy(des, source, source_len);
;;;511    
;;;512    	*p_des_len =  source_len;
;;;513    
;;;514    	return 1;
;;;515    
;;;516    }
0002b4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.696|
0002b8  462a              MOV      r2,r5                 ;510
0002ba  4621              MOV      r1,r4                 ;510
0002bc  4630              MOV      r0,r6                 ;510
0002be  f7fffffe          BL       __aeabi_memcpy
0002c2  f8a85000          STRH     r5,[r8,#0]            ;512
0002c6  2001              MOVS     r0,#1                 ;514
0002c8  e7f4              B        |L1.692|
;;;517    int check_sum_calculate(uint8_t* source,uint16_t source_len,uint16_t* p_des_len)
                          ENDP

                  send_cmd PROC
;;;546    uint8_t send_buf[CFG_SEND_BUF_MAX_LEN] = {0};
;;;547    void send_cmd(uint8_t encryp_type, uint8_t *buf, uint16_t buf_len)
0002ca  b537              PUSH     {r0-r2,r4,r5,lr}
;;;548    {
0002cc  b082              SUB      sp,sp,#8
0002ce  4605              MOV      r5,r0
0002d0  460c              MOV      r4,r1
;;;549    	send_buf[0] = 0x55;
0002d2  2055              MOVS     r0,#0x55
0002d4  495e              LDR      r1,|L1.1104|
0002d6  7008              STRB     r0,[r1,#0]
;;;550    	send_buf[1] = 0xAA;
0002d8  20aa              MOVS     r0,#0xaa
0002da  7048              STRB     r0,[r1,#1]
;;;551    	send_buf[2] = 0x55;
0002dc  2055              MOVS     r0,#0x55
0002de  7088              STRB     r0,[r1,#2]
;;;552    	send_buf[3] = 0xAA;
0002e0  20aa              MOVS     r0,#0xaa
0002e2  70c8              STRB     r0,[r1,#3]
;;;553    
;;;554    	if(encryp_cmd(buf, buf_len, &send_buf[4], CFG_SEND_BUF_MAX_LEN - 4, &buf_len) < 0)
0002e4  a804              ADD      r0,sp,#0x10
0002e6  23fc              MOVS     r3,#0xfc
0002e8  1d0a              ADDS     r2,r1,#4
0002ea  9000              STR      r0,[sp,#0]
0002ec  f8bd1010          LDRH     r1,[sp,#0x10]
0002f0  4620              MOV      r0,r4
0002f2  f7fffffe          BL       encryp_cmd
0002f6  2800              CMP      r0,#0
0002f8  da01              BGE      |L1.766|
                  |L1.762|
;;;555    	{
;;;556    		//TODO: warn
;;;557    		return;
;;;558    	}
;;;559    
;;;560    	if( check_sum_calculate(&send_buf[4],buf_len,&buf_len) < 0)// syn header not check sum
;;;561    	{
;;;562    	    //TODO: warn
;;;563    		return;
;;;564    	}
;;;565    
;;;566    	can_upgrade_ack( (void*)send_buf, buf_len + 4);  //4 is for 0x55AA55AA
;;;567    }
0002fa  b005              ADD      sp,sp,#0x14
0002fc  bd30              POP      {r4,r5,pc}
                  |L1.766|
0002fe  aa04              ADD      r2,sp,#0x10           ;560
000300  f8bd1010          LDRH     r1,[sp,#0x10]         ;560
000304  4852              LDR      r0,|L1.1104|
000306  1d00              ADDS     r0,r0,#4              ;560
000308  f7fffffe          BL       check_sum_calculate
00030c  2800              CMP      r0,#0                 ;560
00030e  da00              BGE      |L1.786|
000310  e7f3              B        |L1.762|
                  |L1.786|
000312  f8bd0010          LDRH     r0,[sp,#0x10]         ;566
000316  1d00              ADDS     r0,r0,#4              ;566
000318  b281              UXTH     r1,r0                 ;566
00031a  484d              LDR      r0,|L1.1104|
00031c  f7fffffe          BL       can_upgrade_ack
000320  bf00              NOP      
000322  e7ea              B        |L1.762|
;;;568    /*******************  (C) COPYRIGHT 2011 DJI ************END OF FILE***********/
                          ENDP

                  cmd_handler_scan PROC
;;;203    
;;;204    void cmd_handler_scan(uint8_t* buf, uint16_t buf_len)
000324  b570              PUSH     {r4-r6,lr}
;;;205    {
000326  b088              SUB      sp,sp,#0x20
000328  4604              MOV      r4,r0
00032a  460d              MOV      r5,r1
;;;206    	CMD_SCAN_ACK_t cmd_scan_ack;
;;;207    	CMD_SCAN_NEW_t *cmd_scan = (CMD_SCAN_NEW_t*)buf;
00032c  4626              MOV      r6,r4
;;;208    
;;;209    	//PC_log_output(2,"scan cmd len %d %d\r\n", sizeof(CMD_SCAN_NEW_t), buf_len);
;;;210      cmd_scan_ack.result = 0;
00032e  2000              MOVS     r0,#0
000330  f88d001e          STRB     r0,[sp,#0x1e]
;;;211    
;;;212    	if(buf_len-4 == sizeof(CMD_SCAN_NEW_t))
000334  1f28              SUBS     r0,r5,#4
000336  281c              CMP      r0,#0x1c
000338  d114              BNE      |L1.868|
;;;213    	{
;;;214    		if(MY_CAN_DEVICE_ID == cmd_scan->canDeviceId)
00033a  7eb0              LDRB     r0,[r6,#0x1a]
00033c  2824              CMP      r0,#0x24
00033e  d111              BNE      |L1.868|
;;;215    		{
;;;216    			init_cmd_header(&cmd_scan_ack.cmd_header,CFG_CMD_ID_SCAN_ACK,sizeof(cmd_scan_ack)+sizeof(uint32_t));
000340  221f              MOVS     r2,#0x1f
000342  f44f7181          MOV      r1,#0x102
000346  a801              ADD      r0,sp,#4
000348  f7fffffe          BL       init_cmd_header
;;;217    			cmd_scan_ack.result = 0;
00034c  2000              MOVS     r0,#0
00034e  f88d001e          STRB     r0,[sp,#0x1e]
;;;218    			uart_printf( 0 ,"scan ack\r\n" );
000352  a140              ADR      r1,|L1.1108|
000354  f7fffffe          BL       uart_printf
;;;219    			send_cmd(cmd_scan_ack.cmd_header.encryp_type, (uint8_t *)(&cmd_scan_ack), sizeof(cmd_scan_ack));
000358  f89d000d          LDRB     r0,[sp,#0xd]
00035c  221b              MOVS     r2,#0x1b
00035e  a901              ADD      r1,sp,#4
000360  f7fffffe          BL       send_cmd
                  |L1.868|
;;;220    		}
;;;221    	}
;;;222    }
000364  b008              ADD      sp,sp,#0x20
000366  bd70              POP      {r4-r6,pc}
;;;223    //
                          ENDP

                  cmd_handler_entry_upgrade_new PROC
;;;224    void cmd_handler_entry_upgrade_new(uint8_t*buf,uint16_t buf_len)
000368  b5f0              PUSH     {r4-r7,lr}
;;;225    {
00036a  b089              SUB      sp,sp,#0x24
00036c  4604              MOV      r4,r0
00036e  460f              MOV      r7,r1
;;;226    	uint32_t i;
;;;227    	CMD_ENTRY_UPGRADE_t     *cmd_entry_upgrade = (CMD_ENTRY_UPGRADE_t*)buf;
000370  4626              MOV      r6,r4
;;;228    	CMD_ENTRY_UPGRADE_ACK_t cmd_entry_upgrade_ack;
;;;229    
;;;230    	if(MY_CAN_DEVICE_ID == cmd_entry_upgrade->canDeviceId)/*  */
000372  7eb0              LDRB     r0,[r6,#0x1a]
000374  2824              CMP      r0,#0x24
000376  d12c              BNE      |L1.978|
;;;231    	{
;;;232    			erase_programming_done_flag();
000378  f7fffffe          BL       erase_programming_done_flag
;;;233    			
;;;234    		if( *( ( uint32_t * )PROGRAM_FLAG_ADDR ) == 0x0 ) {
00037c  f44f4000          MOV      r0,#0x8000
000380  6800              LDR      r0,[r0,#0]
000382  bb30              CBNZ     r0,|L1.978|
;;;235    			cmd_entry_upgrade_ack.cmd_header = cmd_entry_upgrade->cmd_header;
000384  221a              MOVS     r2,#0x1a
000386  4631              MOV      r1,r6
000388  a801              ADD      r0,sp,#4
00038a  f7fffffe          BL       __aeabi_memcpy
;;;236    
;;;237    			init_cmd_header(&cmd_entry_upgrade_ack.cmd_header, CFG_CMDID_ENTRY_UPDATE_NEW_ACK, sizeof(cmd_entry_upgrade_ack)+sizeof(uint32_t) );
00038e  2221              MOVS     r2,#0x21
000390  f64071a1          MOV      r1,#0xfa1
000394  a801              ADD      r0,sp,#4
000396  f7fffffe          BL       init_cmd_header
;;;238    			update_version(cmd_entry_upgrade_ack.cmd_header.device_id);
00039a  f10d000e          ADD      r0,sp,#0xe
00039e  f7fffffe          BL       update_version
;;;239    
;;;240    			cmd_entry_upgrade_ack.result = 0;
0003a2  2000              MOVS     r0,#0
0003a4  f88d001e          STRB     r0,[sp,#0x1e]
;;;241    
;;;242    			send_cmd(cmd_entry_upgrade_ack.cmd_header.encryp_type, (uint8_t*)(&cmd_entry_upgrade_ack), sizeof(cmd_entry_upgrade_ack));
0003a8  f89d000d          LDRB     r0,[sp,#0xd]
0003ac  221d              MOVS     r2,#0x1d
0003ae  a901              ADD      r1,sp,#4
0003b0  f7fffffe          BL       send_cmd
;;;243    			uart_printf(0,"enter upgrade\r\n");
0003b4  a12a              ADR      r1,|L1.1120|
0003b6  2000              MOVS     r0,#0
0003b8  f7fffffe          BL       uart_printf
;;;244    			i = 50000;
0003bc  f24c3550          MOV      r5,#0xc350
;;;245    			while(i--);
0003c0  bf00              NOP      
                  |L1.962|
0003c2  1e28              SUBS     r0,r5,#0
0003c4  f1a50501          SUB      r5,r5,#1
0003c8  d1fb              BNE      |L1.962|
;;;246    
;;;247    			WDT_Feed();  /*看门狗溢出时间同步*/
0003ca  f7fffffe          BL       WDT_Feed
;;;248    			//关中断,停止喂狗,看门狗复位进入bootloader模式
;;;249    			while(1);
0003ce  bf00              NOP      
                  |L1.976|
0003d0  e7fe              B        |L1.976|
                  |L1.978|
;;;250    		}
;;;251    	}
;;;252    }
0003d2  b009              ADD      sp,sp,#0x24
0003d4  bdf0              POP      {r4-r7,pc}
;;;253    
                          ENDP

                  cmd_handler_entry_upgrade_old PROC
;;;254    void cmd_handler_entry_upgrade_old(uint8_t*buf,U16 buf_len)
0003d6  4770              BX       lr
;;;255    {
;;;256    	return;
;;;257    }
;;;258    
                          ENDP

                  cmd_handler_deviceinfo_set PROC
;;;263    CPU_INT08U canSubDeviceId;
;;;264    void cmd_handler_deviceinfo_set(uint8_t*buf, uint16_t buf_len)
0003d8  b5f0              PUSH     {r4-r7,lr}
;;;265    {
0003da  b093              SUB      sp,sp,#0x4c
0003dc  4605              MOV      r5,r0
0003de  460f              MOV      r7,r1
;;;266      CPU_INT32U                    i;
;;;267    	CMD_DEVICEINFO_SET_t         *deviceInfoSet = (CMD_DEVICEINFO_SET_t*)buf;
0003e0  462e              MOV      r6,r5
;;;268    	CMD_DEVICEINFO_REQUEST_ACK_t  cmdACK;
;;;269    	CPU_INT08U TmpId[11];
;;;270    
;;;271    	if(deviceInfoSet->info.canDeviceId == MY_CAN_DEVICE_ID)
0003e2  7eb0              LDRB     r0,[r6,#0x1a]
0003e4  2824              CMP      r0,#0x24
0003e6  d174              BNE      |L1.1234|
;;;272    	{
;;;273    		cmdACK.cmd_header = deviceInfoSet->cmd_header;
0003e8  221a              MOVS     r2,#0x1a
0003ea  4631              MOV      r1,r6
0003ec  a804              ADD      r0,sp,#0x10
0003ee  f7fffffe          BL       __aeabi_memcpy
;;;274    		init_cmd_header(&cmdACK.cmd_header, CFG_CMDID_DEVICEINFO_REQUEST_ACK, sizeof(cmdACK)+sizeof(uint32_t));
0003f2  223f              MOVS     r2,#0x3f
0003f4  f64071b2          MOV      r1,#0xfb2
0003f8  a804              ADD      r0,sp,#0x10
0003fa  f7fffffe          BL       init_cmd_header
;;;275    
;;;276    		cmdACK.result = 0;
0003fe  2000              MOVS     r0,#0
000400  e036              B        |L1.1136|
000402  0000              DCW      0x0000
                  |L1.1028|
                          DCD      cmd_handler_array
                  |L1.1032|
000408  636d6420          DCB      "cmd 0x%04x\r\n",0
00040c  30782530
000410  34780d0a
000414  00      
000415  00                DCB      0
000416  00                DCB      0
000417  00                DCB      0
                  |L1.1048|
                          DCD      can1RxUpgradeRingBuf
                  |L1.1052|
                          DCD      cfg_unpack_state
                  |L1.1056|
                          DCD      cfg_unpack_len_low
                  |L1.1060|
                          DCD      cfg_unpack_len
                  |L1.1064|
                          DCD      cfg_unpack_rdIdx
                  |L1.1068|
                          DCD      cfg_unpack_buf
                  |L1.1072|
000430  34373a25          DCB      "47:%.2x \r\n",0
000434  2e327820
000438  0d0a00  
00043b  00                DCB      0
                  |L1.1084|
                          DCD      loaderVersion
                  |L1.1088|
                          DCD      canDeviceId
                  |L1.1092|
                          DCD      0x010407ff
                  |L1.1096|
                          DCD      fwVersion
                  |L1.1100|
                          DCD      canSubDeviceId
                  |L1.1104|
                          DCD      send_buf
                  |L1.1108|
000454  7363616e          DCB      "scan ack\r\n",0
000458  2061636b
00045c  0d0a00  
00045f  00                DCB      0
                  |L1.1120|
000460  656e7465          DCB      "enter upgrade\r\n",0
000464  72207570
000468  67726164
00046c  650d0a00
                  |L1.1136|
000470  f88d002a          STRB     r0,[sp,#0x2a]
;;;277    
;;;278    		for(i=0; i<10; i++)
000474  2400              MOVS     r4,#0
000476  e005              B        |L1.1156|
                  |L1.1144|
;;;279    		{
;;;280    			ledIdBuf[i] = deviceInfoSet->info.hardwareId[i];
000478  f106001c          ADD      r0,r6,#0x1c
00047c  5d00              LDRB     r0,[r0,r4]
00047e  498b              LDR      r1,|L1.1708|
000480  5508              STRB     r0,[r1,r4]
000482  1c64              ADDS     r4,r4,#1              ;278
                  |L1.1156|
000484  2c0a              CMP      r4,#0xa               ;278
000486  d3f7              BCC      |L1.1144|
;;;281    		}
;;;282    		ledIdBuf[10] = '\0';
000488  2000              MOVS     r0,#0
00048a  4988              LDR      r1,|L1.1708|
00048c  7288              STRB     r0,[r1,#0xa]
;;;283    
;;;284    	    if(hardware_id_write_flash(&ledIdBuf[0],10) == DEF_TRUE)
00048e  210a              MOVS     r1,#0xa
000490  4886              LDR      r0,|L1.1708|
000492  f7fffffe          BL       hardware_id_write_flash
000496  2800              CMP      r0,#0
000498  d125              BNE      |L1.1254|
;;;285    		{
;;;286    		    hardware_id_read_flash(&TmpId[0],10);
00049a  210a              MOVS     r1,#0xa
00049c  a801              ADD      r0,sp,#4
00049e  f7fffffe          BL       hardware_id_read_flash
;;;287    
;;;288    			for(i=0; i<10; i++)
0004a2  2400              MOVS     r4,#0
0004a4  e007              B        |L1.1206|
                  |L1.1190|
;;;289    			{
;;;290    			    if(TmpId[i] != ledIdBuf[i])break;
0004a6  a801              ADD      r0,sp,#4
0004a8  5d00              LDRB     r0,[r0,r4]
0004aa  4980              LDR      r1,|L1.1708|
0004ac  5d09              LDRB     r1,[r1,r4]
0004ae  4288              CMP      r0,r1
0004b0  d000              BEQ      |L1.1204|
0004b2  e002              B        |L1.1210|
                  |L1.1204|
0004b4  1c64              ADDS     r4,r4,#1              ;288
                  |L1.1206|
0004b6  2c0a              CMP      r4,#0xa               ;288
0004b8  d3f5              BCC      |L1.1190|
                  |L1.1210|
0004ba  bf00              NOP      
;;;291    			}
;;;292    
;;;293    			if(10 == i)
0004bc  2c0a              CMP      r4,#0xa
0004be  d109              BNE      |L1.1236|
;;;294    			{
;;;295    			    uart_printf(0,"wkm led write info ok:%s\r\n",&ledIdBuf[0]);
0004c0  4a7a              LDR      r2,|L1.1708|
0004c2  a17b              ADR      r1,|L1.1712|
0004c4  2000              MOVS     r0,#0
0004c6  f7fffffe          BL       uart_printf
;;;296    				cmdACK.result = 0;
0004ca  2000              MOVS     r0,#0
0004cc  f88d002a          STRB     r0,[sp,#0x2a]
0004d0  e011              B        |L1.1270|
                  |L1.1234|
0004d2  e036              B        |L1.1346|
                  |L1.1236|
;;;297    			}
;;;298    			else
;;;299    			{
;;;300    			    uart_printf(0,"wkm led write info err:%s\r\n",&ledIdBuf[0]);
0004d4  4a75              LDR      r2,|L1.1708|
0004d6  a17d              ADR      r1,|L1.1740|
0004d8  2000              MOVS     r0,#0
0004da  f7fffffe          BL       uart_printf
;;;301    				cmdACK.result = 1;
0004de  2001              MOVS     r0,#1
0004e0  f88d002a          STRB     r0,[sp,#0x2a]
0004e4  e007              B        |L1.1270|
                  |L1.1254|
;;;302    			}
;;;303    		}
;;;304    		else
;;;305    		{
;;;306    		    uart_printf(0,"wkm led config err:%s\r\n",&ledIdBuf[0]);
0004e6  4a71              LDR      r2,|L1.1708|
0004e8  a17f              ADR      r1,|L1.1768|
0004ea  2000              MOVS     r0,#0
0004ec  f7fffffe          BL       uart_printf
;;;307    			cmdACK.result = 1;
0004f0  2001              MOVS     r0,#1
0004f2  f88d002a          STRB     r0,[sp,#0x2a]
                  |L1.1270|
;;;308    		}
;;;309    	
;;;310    		hardware_id_read_flash(&TmpId[0],10);
0004f6  210a              MOVS     r1,#0xa
0004f8  a801              ADD      r0,sp,#4
0004fa  f7fffffe          BL       hardware_id_read_flash
;;;311    		
;;;312    		memcpy(cmdACK.info.hardwareId,&TmpId[0],10);
0004fe  f10d0015          ADD      r0,sp,#0x15
000502  9901              LDR      r1,[sp,#4]
000504  f8cd102d          STR      r1,[sp,#0x2d]
000508  9902              LDR      r1,[sp,#8]
00050a  f8cd1031          STR      r1,[sp,#0x31]
00050e  f8bd100c          LDRH     r1,[sp,#0xc]
000512  f8ad1035          STRH     r1,[sp,#0x35]
;;;313    	    cmdACK.info.canSubDeviceId= canSubDeviceId;
000516  487a              LDR      r0,|L1.1792|
000518  7801              LDRB     r1,[r0,#0]  ; canSubDeviceId
00051a  a804              ADD      r0,sp,#0x10
00051c  7701              STRB     r1,[r0,#0x1c]
;;;314    		cmdACK.info.canDeviceId   = canDeviceId;
00051e  4879              LDR      r0,|L1.1796|
000520  7800              LDRB     r0,[r0,#0]  ; canDeviceId
000522  f88d002b          STRB     r0,[sp,#0x2b]
;;;315    		cmdACK.info.loaderVersion = loaderVersion;
000526  4878              LDR      r0,|L1.1800|
000528  6801              LDR      r1,[r0,#0]  ; loaderVersion
00052a  f8cd103b          STR      r1,[sp,#0x3b]
;;;316    		cmdACK.info.fwVersion     = fwVersion;
00052e  4877              LDR      r0,|L1.1804|
000530  6801              LDR      r1,[r0,#0]  ; fwVersion
000532  f8cd1037          STR      r1,[sp,#0x37]
;;;317    		send_cmd(cmdACK.cmd_header.encryp_type, (void *)(&cmdACK), sizeof(cmdACK));
000536  f89d0019          LDRB     r0,[sp,#0x19]
00053a  223b              MOVS     r2,#0x3b
00053c  a904              ADD      r1,sp,#0x10
00053e  f7fffffe          BL       send_cmd
                  |L1.1346|
;;;318    	}
;;;319    }
000542  b013              ADD      sp,sp,#0x4c
000544  bdf0              POP      {r4-r7,pc}
;;;320    
                          ENDP

                  cmd_handler_deviceinfo_check PROC
;;;321    void cmd_handler_deviceinfo_check(uint8_t*buf,uint16_t buf_len)
000546  b570              PUSH     {r4-r6,lr}
;;;322    {
000548  b08e              SUB      sp,sp,#0x38
00054a  4604              MOV      r4,r0
00054c  460e              MOV      r6,r1
;;;323        CMD_DEVICEINFO_CONFIG_CHECK_t     *config_check = (CMD_DEVICEINFO_CONFIG_CHECK_t*)buf;
00054e  4625              MOV      r5,r4
;;;324    	CMD_DEVICEINFO_CONFIG_CHECK_ACK_t  cmdACK;
;;;325    	CPU_INT08U                         TmpId[10];
;;;326    
;;;327    	cmdACK.cmd_header = config_check->cmd_header;
000550  221a              MOVS     r2,#0x1a
000552  4629              MOV      r1,r5
000554  a804              ADD      r0,sp,#0x10
000556  f7fffffe          BL       __aeabi_memcpy
;;;328    	init_cmd_header(&cmdACK.cmd_header, CFG_CMDID_DEVICEINFO_REQUEST_ACK, sizeof(cmdACK)+sizeof(uint32_t));
00055a  222c              MOVS     r2,#0x2c
00055c  f64071b2          MOV      r1,#0xfb2
000560  a804              ADD      r0,sp,#0x10
000562  f7fffffe          BL       init_cmd_header
;;;329    
;;;330    	cmdACK.result       = 0;
000566  2000              MOVS     r0,#0
000568  f88d002a          STRB     r0,[sp,#0x2a]
;;;331    	cmdACK.config_state = 0x01;
00056c  2001              MOVS     r0,#1
00056e  f88d0037          STRB     r0,[sp,#0x37]
;;;332    
;;;333    	hardware_id_read_flash(&TmpId[0],10);
000572  210a              MOVS     r1,#0xa
000574  a801              ADD      r0,sp,#4
000576  f7fffffe          BL       hardware_id_read_flash
;;;334    
;;;335    	uart_printf(0,"wkm led config check!\r\n");
00057a  a165              ADR      r1,|L1.1808|
00057c  2000              MOVS     r0,#0
00057e  f7fffffe          BL       uart_printf
;;;336    
;;;337    	memcpy(&cmdACK.HardWareId[0],&TmpId[0],10);
000582  9801              LDR      r0,[sp,#4]
000584  f8cd002b          STR      r0,[sp,#0x2b]
000588  9802              LDR      r0,[sp,#8]
00058a  f8cd002f          STR      r0,[sp,#0x2f]
00058e  f8bd000c          LDRH     r0,[sp,#0xc]
000592  f8ad0033          STRH     r0,[sp,#0x33]
;;;338    
;;;339    	send_cmd(cmdACK.cmd_header.encryp_type, (void *)(&cmdACK), sizeof(cmdACK));
000596  f89d0019          LDRB     r0,[sp,#0x19]
00059a  2228              MOVS     r2,#0x28
00059c  a904              ADD      r1,sp,#0x10
00059e  f7fffffe          BL       send_cmd
;;;340    }
0005a2  b00e              ADD      sp,sp,#0x38
0005a4  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP

                  cmd_handler_deviceinfo_request PROC
;;;342    void cmd_handler_deviceinfo_request(uint8_t *buf,unsigned short buf_len)
0005a6  b570              PUSH     {r4-r6,lr}
;;;343    {
0005a8  b092              SUB      sp,sp,#0x48
0005aa  4604              MOV      r4,r0
0005ac  460e              MOV      r6,r1
;;;344    	CMD_DEVICEINFO_REQUEST_t     *deviceInfoRequest = (CMD_DEVICEINFO_REQUEST_t*)buf;
0005ae  4625              MOV      r5,r4
;;;345    	CMD_DEVICEINFO_REQUEST_ACK_t deviceInfoRequestAck;
;;;346    	CPU_INT08U                   TmpId[11];
;;;347    
;;;348    	deviceInfoRequestAck.cmd_header = deviceInfoRequest->cmd_header;
0005b0  221a              MOVS     r2,#0x1a
0005b2  4629              MOV      r1,r5
0005b4  a803              ADD      r0,sp,#0xc
0005b6  f7fffffe          BL       __aeabi_memcpy
;;;349    	init_cmd_header(&deviceInfoRequestAck.cmd_header, CFG_CMDID_DEVICEINFO_REQUEST_ACK, sizeof(deviceInfoRequestAck)+sizeof(unsigned int));
0005ba  223f              MOVS     r2,#0x3f
0005bc  f64071b2          MOV      r1,#0xfb2
0005c0  a803              ADD      r0,sp,#0xc
0005c2  f7fffffe          BL       init_cmd_header
;;;350    
;;;351    	deviceInfoRequestAck.result = 0;
0005c6  2000              MOVS     r0,#0
0005c8  f88d0026          STRB     r0,[sp,#0x26]
;;;352    	if(MY_CAN_DEVICE_ID == deviceInfoRequest->canDeviceId)
0005cc  7ea8              LDRB     r0,[r5,#0x1a]
0005ce  2824              CMP      r0,#0x24
0005d0  d131              BNE      |L1.1590|
;;;353    	{
;;;354    
;;;355    		hardware_id_read_flash(&TmpId[0],10);
0005d2  210a              MOVS     r1,#0xa
0005d4  4668              MOV      r0,sp
0005d6  f7fffffe          BL       hardware_id_read_flash
;;;356    		memcpy(deviceInfoRequestAck.info.hardwareId,&TmpId[0],11);
0005da  f10d0029          ADD      r0,sp,#0x29
0005de  9900              LDR      r1,[sp,#0]
0005e0  f8cd1029          STR      r1,[sp,#0x29]
0005e4  9901              LDR      r1,[sp,#4]
0005e6  f8cd102d          STR      r1,[sp,#0x2d]
0005ea  f8bd1008          LDRH     r1,[sp,#8]
0005ee  f8ad1031          STRH     r1,[sp,#0x31]
0005f2  f89d100a          LDRB     r1,[sp,#0xa]
0005f6  7281              STRB     r1,[r0,#0xa]
;;;357    
;;;358    		deviceInfoRequestAck.info.fwVersion      = fwVersion;
0005f8  4844              LDR      r0,|L1.1804|
0005fa  6801              LDR      r1,[r0,#0]  ; fwVersion
0005fc  f8cd1033          STR      r1,[sp,#0x33]
;;;359    		deviceInfoRequestAck.info.loaderVersion  = loaderVersion;
000600  4841              LDR      r0,|L1.1800|
000602  6801              LDR      r1,[r0,#0]  ; loaderVersion
000604  f8cd1037          STR      r1,[sp,#0x37]
;;;360    		deviceInfoRequestAck.info.canDeviceId    = canDeviceId;
000608  483e              LDR      r0,|L1.1796|
00060a  7800              LDRB     r0,[r0,#0]  ; canDeviceId
00060c  f88d0027          STRB     r0,[sp,#0x27]
;;;361    		deviceInfoRequestAck.info.canSubDeviceId = canSubDeviceId;
000610  483b              LDR      r0,|L1.1792|
000612  7801              LDRB     r1,[r0,#0]  ; canSubDeviceId
000614  a803              ADD      r0,sp,#0xc
000616  7701              STRB     r1,[r0,#0x1c]
;;;362    		deviceInfoRequestAck.info.reserved[0]    = 0; /* 1表示在loader模式下 */
000618  2100              MOVS     r1,#0
00061a  f88d103b          STRB     r1,[sp,#0x3b]
;;;363    	  send_cmd(deviceInfoRequestAck.cmd_header.encryp_type, (void *)(&deviceInfoRequestAck), sizeof(deviceInfoRequestAck));
00061e  f89d0015          LDRB     r0,[sp,#0x15]
000622  223b              MOVS     r2,#0x3b
000624  a903              ADD      r1,sp,#0xc
000626  f7fffffe          BL       send_cmd
;;;364    	  uart_printf(0,"led info request:%.2x!\r\n",loaderVersion);
00062a  4837              LDR      r0,|L1.1800|
00062c  a13e              ADR      r1,|L1.1832|
00062e  6802              LDR      r2,[r0,#0]  ; loaderVersion
000630  2000              MOVS     r0,#0
000632  f7fffffe          BL       uart_printf
                  |L1.1590|
;;;365    	}
;;;366    }
000636  b012              ADD      sp,sp,#0x48
000638  bd70              POP      {r4-r6,pc}
;;;367    
                          ENDP

                  cmd_handler_upgrade_start PROC
;;;382    
;;;383    void cmd_handler_upgrade_start(uint8_t* buf, uint16_t buf_len)
00063a  b570              PUSH     {r4-r6,lr}
;;;384    {
00063c  4604              MOV      r4,r0
00063e  460e              MOV      r6,r1
;;;385    	CMD_UPGRADE_START_t* cmd_entry = (CMD_UPGRADE_START_t*)buf;
000640  4625              MOV      r5,r4
;;;386    
;;;387    	if((CAN_DEVICE_ID_CTL == cmd_entry->canDeviceId) || (CAN_DEVICE_ID_RCV == cmd_entry->canDeviceId) || (CAN_DEVICE_ID_DBUS_EXT == cmd_entry->canDeviceId))		
000642  7ea8              LDRB     r0,[r5,#0x1a]
000644  2801              CMP      r0,#1
000646  d005              BEQ      |L1.1620|
000648  7ea8              LDRB     r0,[r5,#0x1a]
00064a  2809              CMP      r0,#9
00064c  d002              BEQ      |L1.1620|
00064e  7ea8              LDRB     r0,[r5,#0x1a]
000650  280f              CMP      r0,#0xf
000652  d103              BNE      |L1.1628|
                  |L1.1620|
;;;388    	{
;;;389    		can_upgrade_ack((void *)buf,buf_len);
000654  4631              MOV      r1,r6
000656  4620              MOV      r0,r4
000658  f7fffffe          BL       can_upgrade_ack
                  |L1.1628|
;;;390    	}
;;;391    }
00065c  bd70              POP      {r4-r6,pc}
;;;392    
                          ENDP

                  cmd_handler_upgrade_data PROC
;;;393    void cmd_handler_upgrade_data(uint8_t* buf, uint16_t buf_len)
00065e  b570              PUSH     {r4-r6,lr}
;;;394    {
000660  4604              MOV      r4,r0
000662  460e              MOV      r6,r1
;;;395    	CMD_UPGRADE_DATA_t* cmd_entry = (CMD_UPGRADE_DATA_t*)buf;
000664  4625              MOV      r5,r4
;;;396    
;;;397    	if((CAN_DEVICE_ID_CTL == cmd_entry->canDeviceId) || (CAN_DEVICE_ID_RCV == cmd_entry->canDeviceId) || (CAN_DEVICE_ID_DBUS_EXT == cmd_entry->canDeviceId))		
000666  7ee8              LDRB     r0,[r5,#0x1b]
000668  2801              CMP      r0,#1
00066a  d005              BEQ      |L1.1656|
00066c  7ee8              LDRB     r0,[r5,#0x1b]
00066e  2809              CMP      r0,#9
000670  d002              BEQ      |L1.1656|
000672  7ee8              LDRB     r0,[r5,#0x1b]
000674  280f              CMP      r0,#0xf
000676  d103              BNE      |L1.1664|
                  |L1.1656|
;;;398    	{
;;;399    		can_upgrade_ack((void *)buf,buf_len);
000678  4631              MOV      r1,r6
00067a  4620              MOV      r0,r4
00067c  f7fffffe          BL       can_upgrade_ack
                  |L1.1664|
;;;400    	}
;;;401    }
000680  bd70              POP      {r4-r6,pc}
;;;402    void cmd_handler_upgrade_end(uint8_t* buf, uint16_t buf_len)
                          ENDP

                  cmd_handler_upgrade_end PROC
000682  460a              MOV      r2,r1
;;;403    {
;;;404    	CMD_UPGRADE_END_t* cmd_entry = (CMD_UPGRADE_END_t*)buf;
000684  4601              MOV      r1,r0
;;;405    
;;;406    	if((CAN_DEVICE_ID_CTL == cmd_entry->canDeviceId) || (CAN_DEVICE_ID_RCV == cmd_entry->canDeviceId) || (CAN_DEVICE_ID_DBUS_EXT == cmd_entry->canDeviceId))		
;;;407    	{
;;;408    //		can_upgrade_ack((void *)buf,buf_len);
;;;409    	}
;;;410    }
000686  4770              BX       lr
;;;411    
                          ENDP

                  cmd_handler_upgrade_check PROC
;;;412    void cmd_handler_upgrade_check(uint8_t* buf, uint16_t buf_len)
000688  b570              PUSH     {r4-r6,lr}
;;;413    {
00068a  4604              MOV      r4,r0
00068c  460e              MOV      r6,r1
;;;414    	CMD_UPGRADE_CHECK_t* cmd_entry = (CMD_UPGRADE_CHECK_t*)buf;
00068e  4625              MOV      r5,r4
;;;415    
;;;416    	if((CAN_DEVICE_ID_CTL == cmd_entry->canDeviceId) || (CAN_DEVICE_ID_RCV == cmd_entry->canDeviceId) || (CAN_DEVICE_ID_DBUS_EXT == cmd_entry->canDeviceId))		
000690  7ea8              LDRB     r0,[r5,#0x1a]
000692  2801              CMP      r0,#1
000694  d005              BEQ      |L1.1698|
000696  7ea8              LDRB     r0,[r5,#0x1a]
000698  2809              CMP      r0,#9
00069a  d002              BEQ      |L1.1698|
00069c  7ea8              LDRB     r0,[r5,#0x1a]
00069e  280f              CMP      r0,#0xf
0006a0  d103              BNE      |L1.1706|
                  |L1.1698|
;;;417    	{
;;;418    		can_upgrade_ack((void *)buf,buf_len);
0006a2  4631              MOV      r1,r6
0006a4  4620              MOV      r0,r4
0006a6  f7fffffe          BL       can_upgrade_ack
                  |L1.1706|
;;;419    	}
;;;420    }
0006aa  bd70              POP      {r4-r6,pc}
;;;421    
                          ENDP

                  |L1.1708|
                          DCD      ledIdBuf
                  |L1.1712|
0006b0  776b6d20          DCB      "wkm led write info ok:%s\r\n",0
0006b4  6c656420
0006b8  77726974
0006bc  6520696e
0006c0  666f206f
0006c4  6b3a2573
0006c8  0d0a00  
0006cb  00                DCB      0
                  |L1.1740|
0006cc  776b6d20          DCB      "wkm led write info err:%s\r\n",0
0006d0  6c656420
0006d4  77726974
0006d8  6520696e
0006dc  666f2065
0006e0  72723a25
0006e4  730d0a00
                  |L1.1768|
0006e8  776b6d20          DCB      "wkm led config err:%s\r\n",0
0006ec  6c656420
0006f0  636f6e66
0006f4  69672065
0006f8  72723a25
0006fc  730d0a00
                  |L1.1792|
                          DCD      canSubDeviceId
                  |L1.1796|
                          DCD      canDeviceId
                  |L1.1800|
                          DCD      loaderVersion
                  |L1.1804|
                          DCD      fwVersion
                  |L1.1808|
000710  776b6d20          DCB      "wkm led config check!\r\n",0
000714  6c656420
000718  636f6e66
00071c  69672063
000720  6865636b
000724  210d0a00
                  |L1.1832|
000728  6c656420          DCB      "led info request:%.2x!\r\n",0
00072c  696e666f
000730  20726571
000734  75657374
000738  3a252e32
00073c  78210d0a
000740  00      
000741  00                DCB      0
000742  00                DCB      0
000743  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ledIdBuf
                          %        11
                  send_buf
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  CAN_CRC_PACK_HEADER1
000000  55                DCB      0x55
                  CAN_CRC_PACK_HEADER2
000001  aa                DCB      0xaa
                  CAN_CRC_PACK_HEADER3
000002  55                DCB      0x55
                  CAN_CRC_PACK_HEADER4
000003  aa                DCB      0xaa
                  CAN_CRC_PACK_STATE_HEADER1
000004  01                DCB      0x01
                  CAN_CRC_PACK_STATE_HEADER2
000005  02                DCB      0x02
                  CAN_CRC_PACK_STATE_HEADER3
000006  03                DCB      0x03
                  CAN_CRC_PACK_STATE_HEADER4
000007  04                DCB      0x04
                  CAN_CRC_PACK_STATE_LEN_L
000008  05                DCB      0x05
                  CAN_CRC_PACK_STATE_LEN_H
000009  06                DCB      0x06
                  CAN_CRC_PACK_STATE_DATA
00000a  07                DCB      0x07
                  CAN_CRC_PACK_STATE_DATA_SIM
00000b  08                DCB      0x08
                  CFG_SEND_BUF_MAX_LEN
00000c  0100              DCW      0x0100
                  CFG_UNPACK_BUF_MAX_LEN
00000e  0200              DCW      0x0200
                  cmd_handler_array
                          DCDU     cmd_handler_entry_upgrade_new
000014  02420000          DCW      0x0242,0x0000
                          DCDU     cmd_handler_entry_upgrade_new
00001c  0fa00000          DCW      0x0fa0,0x0000
                          DCDU     cmd_handler_entry_upgrade_old
000024  02420000          DCW      0x0242,0x0000
                          DCDU     cmd_handler_deviceinfo_set
00002c  0fb00000          DCW      0x0fb0,0x0000
                          DCDU     cmd_handler_deviceinfo_request
000034  0fb10000          DCW      0x0fb1,0x0000
                          DCDU     cmd_handler_scan
00003c  01010000          DCW      0x0101,0x0000
                          DCDU     cmd_handler_upgrade_start
000044  0fa20000          DCW      0x0fa2,0x0000
                          DCDU     cmd_handler_upgrade_data
00004c  0fa40000          DCW      0x0fa4,0x0000
                          DCDU     cmd_handler_upgrade_end
000054  0fa60000          DCW      0x0fa6,0x0000
                          DCDU     cmd_handler_upgrade_check
00005c  0fa80000          DCW      0x0fa8,0x0000
                          DCDU     0x00000000
000064  00000000          DCW      0x0000,0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  cfg_unpack_rdIdx
000000  0000              DCW      0x0000
                  cfg_unpack_len
000002  0000              DCW      0x0000
                  cfg_unpack_len_low
000004  00                DCB      0x00
                  cfg_unpack_state
000005  010000            DCB      0x01,0x00,0x00
                  loaderVersion
                          DCD      0x00000000
                  fwVersion
                          DCD      0x00000000
                  canDeviceId
000010  00                DCB      0x00
                  canSubDeviceId
000011  00                DCB      0x00

                          AREA USB_RAM, DATA, NOINIT, ALIGN=2

                  cfg_unpack_buf
                          %        512
